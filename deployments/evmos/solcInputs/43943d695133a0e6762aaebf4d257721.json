{
  "language": "Solidity",
  "sources": {
    "contracts/CrossChainBridgeBacker_EVMOS_Nomad.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nlibrary Math {\n    \n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\ninterface IAnyswapV4ERC20 {\n  function DOMAIN_SEPARATOR() external view returns(bytes32);\n  function PERMIT_TYPEHASH() external view returns(bytes32);\n  function Swapin(bytes32 txhash, address account, uint256 amount) external returns(bool);\n  function Swapout(uint256 amount, address bindaddr) external returns(bool);\n  function TRANSFER_TYPEHASH() external view returns(bytes32);\n  function allowance(address, address) external view returns(uint256);\n  function applyMinter() external;\n  function applyVault() external;\n  function approve(address spender, uint256 value) external returns(bool);\n  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns(bool);\n  function balanceOf(address) external view returns(uint256);\n  function burn(address from, uint256 amount) external returns(bool);\n  function changeMPCOwner(address newVault) external returns(bool);\n  function changeVault(address newVault) external returns(bool);\n  function decimals() external view returns(uint8);\n  function delay() external view returns(uint256);\n  function delayDelay() external view returns(uint256);\n  function delayMinter() external view returns(uint256);\n  function delayVault() external view returns(uint256);\n  function deposit(uint256 amount, address to) external returns(uint256);\n  function deposit(uint256 amount) external returns(uint256);\n  function deposit() external returns(uint256);\n  function depositVault(uint256 amount, address to) external returns(uint256);\n  function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns(uint256);\n  function depositWithTransferPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns(uint256);\n  function getAllMinters() external view returns(address[] memory);\n  function initVault(address _vault) external;\n  function isMinter(address) external view returns(bool);\n  function mint(address to, uint256 amount) external returns(bool);\n  function minters(uint256) external view returns(address);\n  function mpc() external view returns(address);\n  function name() external view returns(string memory);\n  function nonces(address) external view returns(uint256);\n  function owner() external view returns(address);\n  function pendingDelay() external view returns(uint256);\n  function pendingMinter() external view returns(address);\n  function pendingVault() external view returns(address);\n  function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n  function revokeMinter(address _auth) external;\n  function setMinter(address _auth) external;\n  function setVault(address _vault) external;\n  function setVaultOnly(bool enabled) external;\n  function symbol() external view returns(string memory);\n  function totalSupply() external view returns(uint256);\n  function transfer(address to, uint256 value) external returns(bool);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns(bool);\n  function transferFrom(address from, address to, uint256 value) external returns(bool);\n  function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns(bool);\n  function underlying() external view returns(address);\n  function vault() external view returns(address);\n  function withdraw(uint256 amount, address to) external returns(uint256);\n  function withdraw(uint256 amount) external returns(uint256);\n  function withdraw() external returns(uint256);\n  function withdrawVault(address from, uint256 amount, address to) external returns(uint256);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    \n    function balanceOf(address account) external view returns (uint256);\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n \ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    \n    \n    constructor (string memory __name, string memory __symbol) public {\n        _name = __name;\n        _symbol = __symbol;\n        _decimals = 18;\n    }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    \n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _beforeTokenTransfer(sender, recipient, amount);\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    \n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n    \n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n    \n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n    \n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _beforeTokenTransfer(account, address(0), amount);\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function _burnFrom(address account, uint256 amount) internal virtual {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n    \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ninterface IERC20Permit {\n    \n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n    \n    function nonces(address owner) external view returns (uint256);\n    \n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return;\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n    \n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    \n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    \n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n    \n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    \n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n        return (signer, RecoverError.NoError);\n    }\n    \n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    \n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n    \n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\nabstract contract EIP712 {\n    \n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    \n    \n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    \n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n    \n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\nlibrary Counters {\n    struct Counter {\n        uint256 _value;\n    }\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n    mapping(address => Counters.Counter) private _nonces;\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    \n    constructor(string memory name) EIP712(name, \"1\") {}\n    \n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n        bytes32 hash = _hashTypedDataV4(structHash);\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n        _approve(owner, spender, value);\n    }\n    \n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n    \n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n    function PERMIT_TYPEHASH() external view returns (bytes32) {\n        return _PERMIT_TYPEHASH;\n    }\n    \n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n    function safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n    \n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\ncontract CrossChainCanonical is ERC20Permit, Owned, ReentrancyGuard {\n    using SafeMath for uint256;\n    \n    address public timelock_address;\n    address public custodian_address; \n    uint256 public mint_cap;\n    mapping(address => uint256[2]) public swap_fees;\n    mapping(address => bool) public fee_exempt_list;\n    address[] public bridge_tokens_array;\n    mapping(address => bool) public bridge_tokens;\n    address[] public minters_array;\n    mapping(address => bool) public minters;\n    uint256 private constant PRICE_PRECISION = 1e6;\n    bool public exchangesPaused;\n    mapping(address => bool) public canSwap;\n    \n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n    modifier onlyByOwnGovCust() {\n        require(msg.sender == timelock_address || msg.sender == owner || msg.sender == custodian_address, \"Not owner, tlck, or custd\");\n        _;\n    }\n    modifier onlyMinters() {\n       require(minters[msg.sender], \"Not a minter\");\n        _;\n    } \n    modifier onlyMintersOwnGov() {\n       require(_isMinterOwnGov(msg.sender), \"Not minter, owner, or tlck\");\n        _;\n    } \n    modifier validBridgeToken(address token_address) {\n       require(bridge_tokens[token_address], \"Invalid old token\");\n        _;\n    } \n    \n    constructor (\n        string memory _name,\n        string memory _symbol,\n        address _creator_address,\n        uint256 _initial_mint_amt,\n        address _custodian_address,\n        address[] memory _bridge_tokens\n    ) ERC20(_name, _symbol) ERC20Permit(_name) Owned(_creator_address) {\n        custodian_address = _custodian_address;\n        for (uint256 i = 0; i < _bridge_tokens.length; i++){ \n            bridge_tokens[_bridge_tokens[i]] = true;\n            bridge_tokens_array.push(_bridge_tokens[i]);\n            swap_fees[_bridge_tokens[i]] = [400, 400];\n            canSwap[_bridge_tokens[i]] = true;\n        }\n        mint_cap = _initial_mint_amt;\n        super._mint(_creator_address, _initial_mint_amt);\n    }\n    \n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridge_tokens_array;\n    }\n    function _isMinterOwnGov(address the_address) internal view returns (bool) {\n        return (the_address == timelock_address || the_address == owner || minters[the_address]);\n    }\n    function _isFeeExempt(address the_address) internal view returns (bool) {\n        return (_isMinterOwnGov(the_address) || fee_exempt_list[the_address]);\n    }\n    \n    function _mint_capped(address account, uint256 amount) internal {\n        require(totalSupply() + amount <= mint_cap, \"Mint cap\");\n        super._mint(account, amount);\n    }\n    \n    function exchangeOldForCanonical(address bridge_token_address, uint256 token_amount) external nonReentrant validBridgeToken(bridge_token_address) returns (uint256 canonical_tokens_out) {\n        require(!exchangesPaused && canSwap[bridge_token_address], \"Exchanges paused\");\n        TransferHelper.safeTransferFrom(bridge_token_address, msg.sender, address(this), token_amount);\n        canonical_tokens_out = token_amount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonical_tokens_out -= ((canonical_tokens_out * swap_fees[bridge_token_address][0]) / PRICE_PRECISION);\n        }\n        _mint_capped(msg.sender, canonical_tokens_out);\n    }\n    function exchangeCanonicalForOld(address bridge_token_address, uint256 token_amount) external nonReentrant validBridgeToken(bridge_token_address) returns (uint256 bridge_tokens_out) {\n        require(!exchangesPaused && canSwap[bridge_token_address], \"Exchanges paused\");\n        \n        super._burn(msg.sender, token_amount);\n        bridge_tokens_out = token_amount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridge_tokens_out -= ((bridge_tokens_out * swap_fees[bridge_token_address][1]) / PRICE_PRECISION);\n        }\n        TransferHelper.safeTransfer(bridge_token_address, msg.sender, bridge_tokens_out);\n    }\n    \n    function withdrawBridgeTokens(address bridge_token_address, uint256 bridge_token_amount) external onlyMintersOwnGov validBridgeToken(bridge_token_address) {\n        TransferHelper.safeTransfer(bridge_token_address, msg.sender, bridge_token_amount);\n    }\n    \n    function minter_mint(address m_address, uint256 m_amount) external onlyMinters {\n        _mint_capped(m_address, m_amount);\n        emit TokenMinted(msg.sender, m_address, m_amount);\n    }\n    function minter_burn(uint256 amount) external onlyMinters {\n        super._burn(msg.sender, amount);\n        emit TokenBurned(msg.sender, amount);\n    }\n    \n    function toggleExchanges() external onlyByOwnGovCust {\n        exchangesPaused = !exchangesPaused;\n    }\n    \n    function addBridgeToken(address bridge_token_address, uint256 _brdg_to_can_fee, uint256 _can_to_brdg_fee) external onlyByOwnGov {\n        for (uint i = 0; i < bridge_tokens_array.length; i++){ \n            if (bridge_tokens_array[i] == bridge_token_address){\n                revert(\"Token already present\");\n            }\n        }\n        bridge_tokens[bridge_token_address] = true;\n        bridge_tokens_array.push(bridge_token_address);\n        canSwap[bridge_token_address] = true;\n        swap_fees[bridge_token_address][0] = _brdg_to_can_fee;\n        swap_fees[bridge_token_address][1] = _can_to_brdg_fee;\n        emit BridgeTokenAdded(bridge_token_address);\n    }\n    function toggleBridgeToken(address bridge_token_address) external onlyByOwnGov {\n        bool bridge_tkn_found;\n        for (uint i = 0; i < bridge_tokens_array.length; i++){ \n            if (bridge_tokens_array[i] == bridge_token_address){\n                bridge_tkn_found = true;\n                break;\n            }\n        }\n        require(bridge_tkn_found, \"Bridge tkn not in array\");\n        bridge_tokens[bridge_token_address] = !bridge_tokens[bridge_token_address];\n        canSwap[bridge_token_address] = !canSwap[bridge_token_address];\n        emit BridgeTokenToggled(bridge_token_address, !bridge_tokens[bridge_token_address]);\n    }\n    function addMinter(address minter_address) external onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n        emit MinterAdded(minter_address);\n    }\n    function removeMinter(address minter_address) external onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        delete minters[minter_address];\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0);\n                break;\n            }\n        }\n        emit MinterRemoved(minter_address);\n    }\n    function setMintCap(uint256 _mint_cap) external onlyByOwnGov {\n        mint_cap = _mint_cap;\n        emit MintCapSet(_mint_cap);\n    }\n    function setSwapFees(address bridge_token_address, uint256 _bridge_to_canonical, uint256 _canonical_to_old) external onlyByOwnGov {\n        swap_fees[bridge_token_address] = [_bridge_to_canonical, _canonical_to_old];\n    }\n    function toggleFeesForAddress(address the_address) external onlyByOwnGov {\n        fee_exempt_list[the_address] = !fee_exempt_list[the_address];\n    }\n    function setTimelock(address new_timelock) external onlyByOwnGov {\n        require(new_timelock != address(0), \"Zero address detected\");\n        timelock_address = new_timelock;\n        emit TimelockSet(new_timelock);\n    }\n    function setCustodian(address _custodian_address) external onlyByOwnGov {\n        require(_custodian_address != address(0), \"Zero address detected\");\n        custodian_address = _custodian_address;\n        emit CustodianSet(_custodian_address);\n    }\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(!bridge_tokens[tokenAddress], \"Cannot withdraw bridge tokens\");\n        require(tokenAddress != address(this), \"Cannot withdraw these tokens\");\n        TransferHelper.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n    \n    event TokenBurned(address indexed from, uint256 amount);\n    event TokenMinted(address indexed from, address indexed to, uint256 amount);\n    event BridgeTokenAdded(address indexed bridge_token_address);\n    event BridgeTokenToggled(address indexed bridge_token_address, bool state);\n    event MinterAdded(address pool_address);\n    event MinterRemoved(address pool_address);\n    event MintCapSet(uint256 new_mint_cap);\n    event TimelockSet(address new_timelock);\n    event CustodianSet(address custodian_address);\n}\ninterface IFrax {\n  function COLLATERAL_RATIO_PAUSER() external view returns (bytes32);\n  function DEFAULT_ADMIN_ADDRESS() external view returns (address);\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n  function addPool(address pool_address ) external;\n  function allowance(address owner, address spender ) external view returns (uint256);\n  function approve(address spender, uint256 amount ) external returns (bool);\n  function balanceOf(address account ) external view returns (uint256);\n  function burn(uint256 amount ) external;\n  function burnFrom(address account, uint256 amount ) external;\n  function collateral_ratio_paused() external view returns (bool);\n  function controller_address() external view returns (address);\n  function creator_address() external view returns (address);\n  function decimals() external view returns (uint8);\n  function decreaseAllowance(address spender, uint256 subtractedValue ) external returns (bool);\n  function eth_usd_consumer_address() external view returns (address);\n  function eth_usd_price() external view returns (uint256);\n  function frax_eth_oracle_address() external view returns (address);\n  function frax_info() external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256);\n  function frax_pools(address ) external view returns (bool);\n  function frax_pools_array(uint256 ) external view returns (address);\n  function frax_price() external view returns (uint256);\n  function frax_step() external view returns (uint256);\n  function fxs_address() external view returns (address);\n  function fxs_eth_oracle_address() external view returns (address);\n  function fxs_price() external view returns (uint256);\n  function genesis_supply() external view returns (uint256);\n  function getRoleAdmin(bytes32 role ) external view returns (bytes32);\n  function getRoleMember(bytes32 role, uint256 index ) external view returns (address);\n  function getRoleMemberCount(bytes32 role ) external view returns (uint256);\n  function globalCollateralValue() external view returns (uint256);\n  function global_collateral_ratio() external view returns (uint256);\n  function grantRole(bytes32 role, address account ) external;\n  function hasRole(bytes32 role, address account ) external view returns (bool);\n  function increaseAllowance(address spender, uint256 addedValue ) external returns (bool);\n  function last_call_time() external view returns (uint256);\n  function minting_fee() external view returns (uint256);\n  function name() external view returns (string memory);\n  function owner_address() external view returns (address);\n  function pool_burn_from(address b_address, uint256 b_amount ) external;\n  function pool_mint(address m_address, uint256 m_amount ) external;\n  function price_band() external view returns (uint256);\n  function price_target() external view returns (uint256);\n  function redemption_fee() external view returns (uint256);\n  function refreshCollateralRatio() external;\n  function refresh_cooldown() external view returns (uint256);\n  function removePool(address pool_address ) external;\n  function renounceRole(bytes32 role, address account ) external;\n  function revokeRole(bytes32 role, address account ) external;\n  function setController(address _controller_address ) external;\n  function setETHUSDOracle(address _eth_usd_consumer_address ) external;\n  function setFRAXEthOracle(address _frax_oracle_addr, address _weth_address ) external;\n  function setFXSAddress(address _fxs_address ) external;\n  function setFXSEthOracle(address _fxs_oracle_addr, address _weth_address ) external;\n  function setFraxStep(uint256 _new_step ) external;\n  function setMintingFee(uint256 min_fee ) external;\n  function setOwner(address _owner_address ) external;\n  function setPriceBand(uint256 _price_band ) external;\n  function setPriceTarget(uint256 _new_price_target ) external;\n  function setRedemptionFee(uint256 red_fee ) external;\n  function setRefreshCooldown(uint256 _new_cooldown ) external;\n  function setTimelock(address new_timelock ) external;\n  function symbol() external view returns (string memory);\n  function timelock_address() external view returns (address);\n  function toggleCollateralRatio() external;\n  function totalSupply() external view returns (uint256);\n  function transfer(address recipient, uint256 amount ) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\n  function weth_address() external view returns (address);\n}\ninterface IFxs {\n  function DEFAULT_ADMIN_ROLE() external view returns(bytes32);\n  function FRAXStablecoinAdd() external view returns(address);\n  function FXS_DAO_min() external view returns(uint256);\n  function allowance(address owner, address spender) external view returns(uint256);\n  function approve(address spender, uint256 amount) external returns(bool);\n  function balanceOf(address account) external view returns(uint256);\n  function burn(uint256 amount) external;\n  function burnFrom(address account, uint256 amount) external;\n  function checkpoints(address, uint32) external view returns(uint32 fromBlock, uint96 votes);\n  function decimals() external view returns(uint8);\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns(bool);\n  function genesis_supply() external view returns(uint256);\n  function getCurrentVotes(address account) external view returns(uint96);\n  function getPriorVotes(address account, uint256 blockNumber) external view returns(uint96);\n  function getRoleAdmin(bytes32 role) external view returns(bytes32);\n  function getRoleMember(bytes32 role, uint256 index) external view returns(address);\n  function getRoleMemberCount(bytes32 role) external view returns(uint256);\n  function grantRole(bytes32 role, address account) external;\n  function hasRole(bytes32 role, address account) external view returns(bool);\n  function increaseAllowance(address spender, uint256 addedValue) external returns(bool);\n  function mint(address to, uint256 amount) external;\n  function name() external view returns(string memory);\n  function numCheckpoints(address) external view returns(uint32);\n  function oracle_address() external view returns(address);\n  function owner_address() external view returns(address);\n  function pool_burn_from(address b_address, uint256 b_amount) external;\n  function pool_mint(address m_address, uint256 m_amount) external;\n  function renounceRole(bytes32 role, address account) external;\n  function revokeRole(bytes32 role, address account) external;\n  function setFRAXAddress(address frax_contract_address) external;\n  function setFXSMinDAO(uint256 min_FXS) external;\n  function setOracle(address new_oracle) external;\n  function setOwner(address _owner_address) external;\n  function setTimelock(address new_timelock) external;\n  function symbol() external view returns(string memory);\n  function timelock_address() external view returns(address);\n  function toggleVotes() external;\n  function totalSupply() external view returns(uint256);\n  function trackingVotes() external view returns(bool);\n  function transfer(address recipient, uint256 amount) external returns(bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n}\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\ninterface IFraxAMOMinter {\n  function FRAX() external view returns(address);\n  function FXS() external view returns(address);\n  function acceptOwnership() external;\n  function addAMO(address amo_address, bool sync_too) external;\n  function allAMOAddresses() external view returns(address[] memory);\n  function allAMOsLength() external view returns(uint256);\n  function amos(address) external view returns(bool);\n  function amos_array(uint256) external view returns(address);\n  function burnFraxFromAMO(uint256 frax_amount) external;\n  function burnFxsFromAMO(uint256 fxs_amount) external;\n  function col_idx() external view returns(uint256);\n  function collatDollarBalance() external view returns(uint256);\n  function collatDollarBalanceStored() external view returns(uint256);\n  function collat_borrow_cap() external view returns(int256);\n  function collat_borrowed_balances(address) external view returns(int256);\n  function collat_borrowed_sum() external view returns(int256);\n  function collateral_address() external view returns(address);\n  function collateral_token() external view returns(address);\n  function correction_offsets_amos(address, uint256) external view returns(int256);\n  function custodian_address() external view returns(address);\n  function dollarBalances() external view returns(uint256 frax_val_e18, uint256 collat_val_e18);\n  function fraxDollarBalanceStored() external view returns(uint256);\n  function fraxTrackedAMO(address amo_address) external view returns(int256);\n  function fraxTrackedGlobal() external view returns(int256);\n  function frax_mint_balances(address) external view returns(int256);\n  function frax_mint_cap() external view returns(int256);\n  function frax_mint_sum() external view returns(int256);\n  function fxs_mint_balances(address) external view returns(int256);\n  function fxs_mint_cap() external view returns(int256);\n  function fxs_mint_sum() external view returns(int256);\n  function giveCollatToAMO(address destination_amo, uint256 collat_amount) external;\n  function min_cr() external view returns(uint256);\n  function mintFraxForAMO(address destination_amo, uint256 frax_amount) external;\n  function mintFxsForAMO(address destination_amo, uint256 fxs_amount) external;\n  function missing_decimals() external view returns(uint256);\n  function nominateNewOwner(address _owner) external;\n  function nominatedOwner() external view returns(address);\n  function oldPoolCollectAndGive(address destination_amo) external;\n  function oldPoolRedeem(uint256 frax_amount) external;\n  function old_pool() external view returns(address);\n  function owner() external view returns(address);\n  function pool() external view returns(address);\n  function receiveCollatFromAMO(uint256 usdc_amount) external;\n  function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\n  function removeAMO(address amo_address, bool sync_too) external;\n  function setAMOCorrectionOffsets(address amo_address, int256 frax_e18_correction, int256 collat_e18_correction) external;\n  function setCollatBorrowCap(uint256 _collat_borrow_cap) external;\n  function setCustodian(address _custodian_address) external;\n  function setFraxMintCap(uint256 _frax_mint_cap) external;\n  function setFraxPool(address _pool_address) external;\n  function setFxsMintCap(uint256 _fxs_mint_cap) external;\n  function setMinimumCollateralRatio(uint256 _min_cr) external;\n  function setTimelock(address new_timelock) external;\n  function syncDollarBalances() external;\n  function timelock_address() external view returns(address);\n}\ncontract FraxPoolV3 is Owned {\n    using SafeMath for uint256;\n    \n    address public timelock_address;\n    address public custodian_address;\n    IFrax private FRAX = IFrax(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    IFxs private FXS = IFxs(0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0);\n    mapping(address => bool) public amo_minter_addresses;\n    AggregatorV3Interface public priceFeedFRAXUSD = AggregatorV3Interface(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD);\n    AggregatorV3Interface public priceFeedFXSUSD = AggregatorV3Interface(0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f);\n    uint256 private chainlink_frax_usd_decimals;\n    uint256 private chainlink_fxs_usd_decimals;\n    address[] public collateral_addresses;\n    string[] public collateral_symbols;\n    uint256[] public missing_decimals;\n    uint256[] public pool_ceilings;\n    uint256[] public collateral_prices;\n    mapping(address => uint256) public collateralAddrToIdx;\n    mapping(address => bool) public enabled_collaterals;\n    \n    mapping (address => uint256) public redeemFXSBalances;\n    mapping (address => mapping(uint256 => uint256)) public redeemCollateralBalances;\n    uint256[] public unclaimedPoolCollateral;\n    uint256 public unclaimedPoolFXS;\n    mapping (address => uint256) public lastRedeemed;\n    uint256 public redemption_delay = 2;\n    uint256 public redeem_price_threshold = 990000;\n    uint256 public mint_price_threshold = 1010000;\n    \n    mapping(uint256 => uint256) public bbkHourlyCum;\n    uint256 public bbkMaxColE18OutPerHour = 1000e18;\n    mapping(uint256 => uint256) public rctHourlyCum;\n    uint256 public rctMaxFxsOutPerHour = 1000e18;\n    uint256[] private minting_fee;\n    uint256[] private redemption_fee;\n    uint256[] private buyback_fee;\n    uint256[] private recollat_fee;\n    uint256 public bonus_rate;\n    \n    uint256 private constant PRICE_PRECISION = 1e6;\n    bool[] private mintPaused;\n    bool[] private redeemPaused;\n    bool[] private recollateralizePaused;\n    bool[] private buyBackPaused;\n    bool[] private borrowingPaused;\n    \n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n    modifier onlyByOwnGovCust() {\n        require(msg.sender == timelock_address || msg.sender == owner || msg.sender == custodian_address, \"Not owner, tlck, or custd\");\n        _;\n    }\n    modifier onlyAMOMinters() {\n        require(amo_minter_addresses[msg.sender], \"Not an AMO Minter\");\n        _;\n    }\n    modifier collateralEnabled(uint256 col_idx) {\n        require(enabled_collaterals[collateral_addresses[col_idx]], \"Collateral disabled\");\n        _;\n    }\n \n    \n    \n    constructor (\n        address _pool_manager_address,\n        address _custodian_address,\n        address _timelock_address,\n        address[] memory _collateral_addresses,\n        uint256[] memory _pool_ceilings,\n        uint256[] memory _initial_fees\n    ) Owned(_pool_manager_address){\n        timelock_address = _timelock_address;\n        custodian_address = _custodian_address;\n        collateral_addresses = _collateral_addresses;\n        for (uint256 i = 0; i < _collateral_addresses.length; i++){ \n            collateralAddrToIdx[_collateral_addresses[i]] = i;\n            enabled_collaterals[_collateral_addresses[i]] = false;\n            missing_decimals.push(uint256(18).sub(ERC20(_collateral_addresses[i]).decimals()));\n            collateral_symbols.push(ERC20(_collateral_addresses[i]).symbol());\n            unclaimedPoolCollateral.push(0);\n            collateral_prices.push(PRICE_PRECISION);\n            minting_fee.push(_initial_fees[0]);\n            redemption_fee.push(_initial_fees[1]);\n            buyback_fee.push(_initial_fees[2]);\n            recollat_fee.push(_initial_fees[3]);\n            mintPaused.push(false);\n            redeemPaused.push(false);\n            recollateralizePaused.push(false);\n            buyBackPaused.push(false);\n            borrowingPaused.push(false);\n        }\n        pool_ceilings = _pool_ceilings;\n        chainlink_frax_usd_decimals = priceFeedFRAXUSD.decimals();\n        chainlink_fxs_usd_decimals = priceFeedFXSUSD.decimals();\n    }\n    \n    \n    struct CollateralInformation {\n        uint256 index;\n        string symbol;\n        address col_addr;\n        bool is_enabled;\n        uint256 missing_decs;\n        uint256 price;\n        uint256 pool_ceiling;\n        bool mint_paused;\n        bool redeem_paused;\n        bool recollat_paused;\n        bool buyback_paused;\n        bool borrowing_paused;\n        uint256 minting_fee;\n        uint256 redemption_fee;\n        uint256 buyback_fee;\n        uint256 recollat_fee;\n    }\n    \n    function collateral_information(address collat_address) external view returns (CollateralInformation memory return_data){\n        require(enabled_collaterals[collat_address], \"Invalid collateral\");\n        uint256 idx = collateralAddrToIdx[collat_address];\n        \n        return_data = CollateralInformation(\n            idx,\n            collateral_symbols[idx],\n            collat_address,\n            enabled_collaterals[collat_address],\n            missing_decimals[idx],\n            collateral_prices[idx],\n            pool_ceilings[idx],\n            mintPaused[idx],\n            redeemPaused[idx],\n            recollateralizePaused[idx],\n            buyBackPaused[idx],\n            borrowingPaused[idx],\n            minting_fee[idx],\n            redemption_fee[idx],\n            buyback_fee[idx],\n            recollat_fee[idx]\n        );\n    }\n    function allCollaterals() external view returns (address[] memory) {\n        return collateral_addresses;\n    }\n    function getFRAXPrice() public view returns (uint256) {\n        (uint80 roundID, int price, , uint256 updatedAt, uint80 answeredInRound) = priceFeedFRAXUSD.latestRoundData();\n        require(price >= 0 && updatedAt!= 0 && answeredInRound >= roundID, \"Invalid chainlink price\");\n        return uint256(price).mul(PRICE_PRECISION).div(10 ** chainlink_frax_usd_decimals);\n    }\n    function getFXSPrice() public view returns (uint256) {\n        (uint80 roundID, int price, , uint256 updatedAt, uint80 answeredInRound) = priceFeedFXSUSD.latestRoundData();\n        require(price >= 0 && updatedAt!= 0 && answeredInRound >= roundID, \"Invalid chainlink price\");\n        return uint256(price).mul(PRICE_PRECISION).div(10 ** chainlink_fxs_usd_decimals);\n    }\n    function getFRAXInCollateral(uint256 col_idx, uint256 frax_amount) public view returns (uint256) {\n        return frax_amount.mul(PRICE_PRECISION).div(10 ** missing_decimals[col_idx]).div(collateral_prices[col_idx]);\n    }\n    function freeCollatBalance(uint256 col_idx) public view returns (uint256) {\n        return ERC20(collateral_addresses[col_idx]).balanceOf(address(this)).sub(unclaimedPoolCollateral[col_idx]);\n    }\n    function collatDollarBalance() external view returns (uint256 balance_tally) {\n        balance_tally = 0;\n        for (uint256 i = 0; i < collateral_addresses.length; i++){ \n            balance_tally += freeCollatBalance(i).mul(10 ** missing_decimals[i]).mul(collateral_prices[i]).div(PRICE_PRECISION);\n        }\n    }\n    function comboCalcBbkRct(uint256 cur, uint256 max, uint256 theo) internal pure returns (uint256) {\n        if (cur >= max) {\n            return 0;\n        }\n        else {\n            uint256 available = max.sub(cur);\n            if (theo >= available) {\n                return available;\n            }\n            else {\n                return theo;\n            }\n        } \n    }\n    function buybackAvailableCollat() public view returns (uint256) {\n        uint256 total_supply = FRAX.totalSupply();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        uint256 global_collat_value = FRAX.globalCollateralValue();\n        if (global_collateral_ratio > PRICE_PRECISION) global_collateral_ratio = PRICE_PRECISION;\n        uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(PRICE_PRECISION);\n        \n        if (global_collat_value > required_collat_dollar_value_d18) {\n            uint256 theoretical_bbk_amt = global_collat_value.sub(required_collat_dollar_value_d18);\n            uint256 current_hr_bbk = bbkHourlyCum[curEpochHr()];\n            return comboCalcBbkRct(current_hr_bbk, bbkMaxColE18OutPerHour, theoretical_bbk_amt);\n        }\n        else return 0;\n    }\n    function recollatTheoColAvailableE18() public view returns (uint256) {\n        uint256 frax_total_supply = FRAX.totalSupply();\n        uint256 effective_collateral_ratio = FRAX.globalCollateralValue().mul(PRICE_PRECISION).div(frax_total_supply);\n        \n        uint256 desired_collat_e24 = (FRAX.global_collateral_ratio()).mul(frax_total_supply);\n        uint256 effective_collat_e24 = effective_collateral_ratio.mul(frax_total_supply);\n        if (effective_collat_e24 >= desired_collat_e24) return 0;\n        else {\n            return (desired_collat_e24.sub(effective_collat_e24)).div(PRICE_PRECISION);\n        }\n    }\n    function recollatAvailableFxs() public view returns (uint256) {\n        uint256 fxs_price = getFXSPrice();\n        uint256 recollat_theo_available_e18 = recollatTheoColAvailableE18();\n        uint256 fxs_theo_out = recollat_theo_available_e18.mul(PRICE_PRECISION).div(fxs_price);\n        uint256 current_hr_rct = rctHourlyCum[curEpochHr()];\n        return comboCalcBbkRct(current_hr_rct, rctMaxFxsOutPerHour, fxs_theo_out);\n    }\n    function curEpochHr() public view returns (uint256) {\n        return (block.timestamp / 3600);\n    }\n    \n     function mintFrax(\n        uint256 col_idx, \n        uint256 frax_amt,\n        uint256 frax_out_min,\n        uint256 max_collat_in,\n        uint256 max_fxs_in,\n        bool one_to_one_override\n    ) external collateralEnabled(col_idx) returns (\n        uint256 total_frax_mint, \n        uint256 collat_needed, \n        uint256 fxs_needed\n    ) {\n        require(mintPaused[col_idx] == false, \"Minting is paused\");\n        require(getFRAXPrice() >= mint_price_threshold, \"Frax price too low\");\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        if (one_to_one_override || global_collateral_ratio >= PRICE_PRECISION) { \n            collat_needed = getFRAXInCollateral(col_idx, frax_amt);\n            fxs_needed = 0;\n        } else if (global_collateral_ratio == 0) { \n            collat_needed = 0;\n            fxs_needed = frax_amt.mul(PRICE_PRECISION).div(getFXSPrice());\n        } else { \n            uint256 frax_for_collat = frax_amt.mul(global_collateral_ratio).div(PRICE_PRECISION);\n            uint256 frax_for_fxs = frax_amt.sub(frax_for_collat);\n            collat_needed = getFRAXInCollateral(col_idx, frax_for_collat);\n            fxs_needed = frax_for_fxs.mul(PRICE_PRECISION).div(getFXSPrice());\n        }\n        total_frax_mint = (frax_amt.mul(PRICE_PRECISION.sub(minting_fee[col_idx]))).div(PRICE_PRECISION);\n        require((total_frax_mint >= frax_out_min), \"FRAX slippage\");\n        require((collat_needed <= max_collat_in), \"Collat slippage\");\n        require((fxs_needed <= max_fxs_in), \"FXS slippage\");\n        require(freeCollatBalance(col_idx).add(collat_needed) <= pool_ceilings[col_idx], \"Pool ceiling\");\n        FXS.pool_burn_from(msg.sender, fxs_needed);\n        TransferHelper.safeTransferFrom(collateral_addresses[col_idx], msg.sender, address(this), collat_needed);\n        FRAX.pool_mint(msg.sender, total_frax_mint);\n    }\n    function redeemFrax(\n        uint256 col_idx, \n        uint256 frax_amount, \n        uint256 fxs_out_min, \n        uint256 col_out_min\n    ) external collateralEnabled(col_idx) returns (\n        uint256 collat_out, \n        uint256 fxs_out\n    ) {\n        require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\n        require(getFRAXPrice() <= redeem_price_threshold, \"Frax price too high\");\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        uint256 frax_after_fee = (frax_amount.mul(PRICE_PRECISION.sub(redemption_fee[col_idx]))).div(PRICE_PRECISION);\n        if(global_collateral_ratio >= PRICE_PRECISION) { \n            collat_out = getFRAXInCollateral(col_idx, frax_after_fee);\n            fxs_out = 0;\n        } else if (global_collateral_ratio == 0) { \n            fxs_out = frax_after_fee\n                            .mul(PRICE_PRECISION)\n                            .div(getFXSPrice());\n            collat_out = 0;\n        } else { \n            collat_out = getFRAXInCollateral(col_idx, frax_after_fee)\n                            .mul(global_collateral_ratio)\n                            .div(PRICE_PRECISION);\n            fxs_out = frax_after_fee\n                            .mul(PRICE_PRECISION.sub(global_collateral_ratio))\n                            .div(getFXSPrice());\n        }\n        require(collat_out <= (ERC20(collateral_addresses[col_idx])).balanceOf(address(this)).sub(unclaimedPoolCollateral[col_idx]), \"Insufficient pool collateral\");\n        require(collat_out >= col_out_min, \"Collateral slippage\");\n        require(fxs_out >= fxs_out_min, \"FXS slippage\");\n        redeemCollateralBalances[msg.sender][col_idx] = redeemCollateralBalances[msg.sender][col_idx].add(collat_out);\n        unclaimedPoolCollateral[col_idx] = unclaimedPoolCollateral[col_idx].add(collat_out);\n        redeemFXSBalances[msg.sender] = redeemFXSBalances[msg.sender].add(fxs_out);\n        unclaimedPoolFXS = unclaimedPoolFXS.add(fxs_out);\n        lastRedeemed[msg.sender] = block.number;\n        FRAX.pool_burn_from(msg.sender, frax_amount);\n        FXS.pool_mint(address(this), fxs_out);\n    }\n    function collectRedemption(uint256 col_idx) external returns (uint256 fxs_amount, uint256 collateral_amount) {\n        require(redeemPaused[col_idx] == false, \"Redeeming is paused\");\n        require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Too soon\");\n        bool sendFXS = false;\n        bool sendCollateral = false;\n        if(redeemFXSBalances[msg.sender] > 0){\n            fxs_amount = redeemFXSBalances[msg.sender];\n            redeemFXSBalances[msg.sender] = 0;\n            unclaimedPoolFXS = unclaimedPoolFXS.sub(fxs_amount);\n            sendFXS = true;\n        }\n        \n        if(redeemCollateralBalances[msg.sender][col_idx] > 0){\n            collateral_amount = redeemCollateralBalances[msg.sender][col_idx];\n            redeemCollateralBalances[msg.sender][col_idx] = 0;\n            unclaimedPoolCollateral[col_idx] = unclaimedPoolCollateral[col_idx].sub(collateral_amount);\n            sendCollateral = true;\n        }\n        if(sendFXS){\n            TransferHelper.safeTransfer(address(FXS), msg.sender, fxs_amount);\n        }\n        if(sendCollateral){\n            TransferHelper.safeTransfer(collateral_addresses[col_idx], msg.sender, collateral_amount);\n        }\n    }\n    function buyBackFxs(uint256 col_idx, uint256 fxs_amount, uint256 col_out_min) external collateralEnabled(col_idx) returns (uint256 col_out) {\n        require(buyBackPaused[col_idx] == false, \"Buyback is paused\");\n        uint256 fxs_price = getFXSPrice();\n        uint256 available_excess_collat_dv = buybackAvailableCollat();\n        require(available_excess_collat_dv > 0, \"Insuf Collat Avail For BBK\");\n        uint256 fxs_dollar_value_d18 = fxs_amount.mul(fxs_price).div(PRICE_PRECISION);\n        require(fxs_dollar_value_d18 <= available_excess_collat_dv, \"Insuf Collat Avail For BBK\");\n        uint256 collateral_equivalent_d18 = fxs_dollar_value_d18.mul(PRICE_PRECISION).div(collateral_prices[col_idx]);\n        col_out = collateral_equivalent_d18.div(10 ** missing_decimals[col_idx]);\n        col_out = (col_out.mul(PRICE_PRECISION.sub(buyback_fee[col_idx]))).div(PRICE_PRECISION);\n        require(col_out >= col_out_min, \"Collateral slippage\");\n        FXS.pool_burn_from(msg.sender, fxs_amount);\n        TransferHelper.safeTransfer(collateral_addresses[col_idx], msg.sender, col_out);\n        bbkHourlyCum[curEpochHr()] += collateral_equivalent_d18;\n    }\n    function recollateralize(uint256 col_idx, uint256 collateral_amount, uint256 fxs_out_min) external collateralEnabled(col_idx) returns (uint256 fxs_out) {\n        require(recollateralizePaused[col_idx] == false, \"Recollat is paused\");\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals[col_idx]);\n        uint256 fxs_price = getFXSPrice();\n        uint256 fxs_actually_available = recollatAvailableFxs();\n        fxs_out = collateral_amount_d18.mul(PRICE_PRECISION.add(bonus_rate).sub(recollat_fee[col_idx])).div(fxs_price);\n        require(fxs_out <= fxs_actually_available, \"Insuf FXS Avail For RCT\");\n        require(fxs_out >= fxs_out_min, \"FXS slippage\");\n        require(freeCollatBalance(col_idx).add(collateral_amount) <= pool_ceilings[col_idx], \"Pool ceiling\");\n        TransferHelper.safeTransferFrom(collateral_addresses[col_idx], msg.sender, address(this), collateral_amount);\n        FXS.pool_mint(msg.sender, fxs_out);\n        rctHourlyCum[curEpochHr()] += fxs_out;\n    }\n    function amoMinterBorrow(uint256 collateral_amount) external onlyAMOMinters {\n        uint256 minter_col_idx = IFraxAMOMinter(msg.sender).col_idx();\n        require(borrowingPaused[minter_col_idx] == false, \"Borrowing is paused\");\n        require(enabled_collaterals[collateral_addresses[minter_col_idx]], \"Collateral disabled\");\n        TransferHelper.safeTransfer(collateral_addresses[minter_col_idx], msg.sender, collateral_amount);\n    }\n    \n    function toggleMRBR(uint256 col_idx, uint8 tog_idx) external onlyByOwnGovCust {\n        if (tog_idx == 0) mintPaused[col_idx] = !mintPaused[col_idx];\n        else if (tog_idx == 1) redeemPaused[col_idx] = !redeemPaused[col_idx];\n        else if (tog_idx == 2) buyBackPaused[col_idx] = !buyBackPaused[col_idx];\n        else if (tog_idx == 3) recollateralizePaused[col_idx] = !recollateralizePaused[col_idx];\n        else if (tog_idx == 4) borrowingPaused[col_idx] = !borrowingPaused[col_idx];\n        emit MRBRToggled(col_idx, tog_idx);\n    }\n    \n    function addAMOMinter(address amo_minter_addr) external onlyByOwnGov {\n        require(amo_minter_addr != address(0), \"Zero address detected\");\n        uint256 collat_val_e18 = IFraxAMOMinter(amo_minter_addr).collatDollarBalance();\n        require(collat_val_e18 >= 0, \"Invalid AMO\");\n        amo_minter_addresses[amo_minter_addr] = true;\n        emit AMOMinterAdded(amo_minter_addr);\n    }\n    function removeAMOMinter(address amo_minter_addr) external onlyByOwnGov {\n        amo_minter_addresses[amo_minter_addr] = false;\n        \n        emit AMOMinterRemoved(amo_minter_addr);\n    }\n    function setCollateralPrice(uint256 col_idx, uint256 _new_price) external onlyByOwnGov {\n        collateral_prices[col_idx] = _new_price;\n        emit CollateralPriceSet(col_idx, _new_price);\n    }\n    function toggleCollateral(uint256 col_idx) external onlyByOwnGov {\n        address col_address = collateral_addresses[col_idx];\n        enabled_collaterals[col_address] = !enabled_collaterals[col_address];\n        emit CollateralToggled(col_idx, enabled_collaterals[col_address]);\n    }\n    function setPoolCeiling(uint256 col_idx, uint256 new_ceiling) external onlyByOwnGov {\n        pool_ceilings[col_idx] = new_ceiling;\n        emit PoolCeilingSet(col_idx, new_ceiling);\n    }\n    function setFees(uint256 col_idx, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external onlyByOwnGov {\n        minting_fee[col_idx] = new_mint_fee;\n        redemption_fee[col_idx] = new_redeem_fee;\n        buyback_fee[col_idx] = new_buyback_fee;\n        recollat_fee[col_idx] = new_recollat_fee;\n        emit FeesSet(col_idx, new_mint_fee, new_redeem_fee, new_buyback_fee, new_recollat_fee);\n    }\n    function setPoolParameters(uint256 new_bonus_rate, uint256 new_redemption_delay) external onlyByOwnGov {\n        bonus_rate = new_bonus_rate;\n        redemption_delay = new_redemption_delay;\n        emit PoolParametersSet(new_bonus_rate, new_redemption_delay);\n    }\n    function setPriceThresholds(uint256 new_mint_price_threshold, uint256 new_redeem_price_threshold) external onlyByOwnGov {\n        mint_price_threshold = new_mint_price_threshold;\n        redeem_price_threshold = new_redeem_price_threshold;\n        emit PriceThresholdsSet(new_mint_price_threshold, new_redeem_price_threshold);\n    }\n    function setBbkRctPerHour(uint256 _bbkMaxColE18OutPerHour, uint256 _rctMaxFxsOutPerHour) external onlyByOwnGov {\n        bbkMaxColE18OutPerHour = _bbkMaxColE18OutPerHour;\n        rctMaxFxsOutPerHour = _rctMaxFxsOutPerHour;\n        emit BbkRctPerHourSet(_bbkMaxColE18OutPerHour, _rctMaxFxsOutPerHour);\n    }\n    function setOracles(address _frax_usd_chainlink_addr, address _fxs_usd_chainlink_addr) external onlyByOwnGov {\n        priceFeedFRAXUSD = AggregatorV3Interface(_frax_usd_chainlink_addr);\n        priceFeedFXSUSD = AggregatorV3Interface(_fxs_usd_chainlink_addr);\n        chainlink_frax_usd_decimals = priceFeedFRAXUSD.decimals();\n        chainlink_fxs_usd_decimals = priceFeedFXSUSD.decimals();\n        \n        emit OraclesSet(_frax_usd_chainlink_addr, _fxs_usd_chainlink_addr);\n    }\n    function setCustodian(address new_custodian) external onlyByOwnGov {\n        custodian_address = new_custodian;\n        emit CustodianSet(new_custodian);\n    }\n    function setTimelock(address new_timelock) external onlyByOwnGov {\n        timelock_address = new_timelock;\n        emit TimelockSet(new_timelock);\n    }\n    \n    event CollateralToggled(uint256 col_idx, bool new_state);\n    event PoolCeilingSet(uint256 col_idx, uint256 new_ceiling);\n    event FeesSet(uint256 col_idx, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee);\n    event PoolParametersSet(uint256 new_bonus_rate, uint256 new_redemption_delay);\n    event PriceThresholdsSet(uint256 new_bonus_rate, uint256 new_redemption_delay);\n    event BbkRctPerHourSet(uint256 bbkMaxColE18OutPerHour, uint256 rctMaxFxsOutPerHour);\n    event AMOMinterAdded(address amo_minter_addr);\n    event AMOMinterRemoved(address amo_minter_addr);\n    event OraclesSet(address frax_usd_chainlink_addr, address fxs_usd_chainlink_addr);\n    event CustodianSet(address new_custodian);\n    event TimelockSet(address new_timelock);\n    event MRBRToggled(uint256 col_idx, uint8 tog_idx);\n    event CollateralPriceSet(uint256 col_idx, uint256 new_price);\n}\ninterface IFraxPool {\n    function minting_fee() external returns (uint256);\n    function redeemCollateralBalances(address addr) external returns (uint256);\n    function redemption_fee() external returns (uint256);\n    function buyback_fee() external returns (uint256);\n    function recollat_fee() external returns (uint256);\n    function collatDollarBalance() external returns (uint256);\n    function availableExcessCollatDV() external returns (uint256);\n    function getCollateralPrice() external returns (uint256);\n    function setCollatETHOracle(address _collateral_weth_oracle_address, address _weth_address) external;\n    function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external;\n    function mintAlgorithmicFRAX(uint256 fxs_amount_d18, uint256 FRAX_out_min) external;\n    function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external;\n    function redeem1t1FRAX(uint256 FRAX_amount, uint256 COLLATERAL_out_min) external;\n    function redeemFractionalFRAX(uint256 FRAX_amount, uint256 FXS_out_min, uint256 COLLATERAL_out_min) external;\n    function redeemAlgorithmicFRAX(uint256 FRAX_amount, uint256 FXS_out_min) external;\n    function collectRedemption() external;\n    function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external;\n    function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external;\n    function toggleMinting() external;\n    function toggleRedeeming() external;\n    function toggleRecollateralize() external;\n    function toggleBuyBack() external;\n    function toggleCollateralPrice(uint256 _new_price) external;\n    function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay, uint256 new_mint_fee, uint256 new_redeem_fee, uint256 new_buyback_fee, uint256 new_recollat_fee) external;\n    function setTimelock(address new_timelock) external;\n    function setOwner(address _owner_address) external;\n}\npragma experimental ABIEncoderV2;\ninterface IAMO {\n    function dollarBalances() external view returns (uint256 frax_val_e18, uint256 collat_val_e18);\n}\ncontract FraxAMOMinter is Owned {\n    \n    IFrax public FRAX = IFrax(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    IFxs public FXS = IFxs(0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0);\n    ERC20 public collateral_token;\n    FraxPoolV3 public pool = FraxPoolV3(0x2fE065e6FFEf9ac95ab39E5042744d695F560729);\n    IFraxPool public old_pool = IFraxPool(0x1864Ca3d47AaB98Ee78D11fc9DCC5E7bADdA1c0d);\n    address public timelock_address;\n    address public custodian_address;\n    address public collateral_address;\n    uint256 public col_idx;\n    address[] public amos_array;\n    mapping(address => bool) public amos;\n    uint256 private constant PRICE_PRECISION = 1e6;\n    int256 public collat_borrow_cap = int256(10000000e6);\n    int256 public frax_mint_cap = int256(100000000e18);\n    int256 public fxs_mint_cap = int256(100000000e18);\n    uint256 public min_cr = 810000;\n    mapping(address => int256) public frax_mint_balances;\n    int256 public frax_mint_sum = 0;\n    mapping(address => int256) public fxs_mint_balances;\n    int256 public fxs_mint_sum = 0;\n    mapping(address => int256) public collat_borrowed_balances;\n    int256 public collat_borrowed_sum = 0;\n    uint256 public fraxDollarBalanceStored = 0;\n    uint256 public missing_decimals;\n    uint256 public collatDollarBalanceStored = 0;\n    mapping(address => int256[2]) public correction_offsets_amos;\n    \n    \n    constructor (\n        address _owner_address,\n        address _custodian_address,\n        address _timelock_address,\n        address _collateral_address,\n        address _pool_address\n    ) Owned(_owner_address) {\n        custodian_address = _custodian_address;\n        timelock_address = _timelock_address;\n        pool = FraxPoolV3(_pool_address);\n        collateral_address = _collateral_address;\n        col_idx = pool.collateralAddrToIdx(_collateral_address);\n        collateral_token = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n        missing_decimals = uint(18) - collateral_token.decimals();\n    }\n    \n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n    modifier validAMO(address amo_address) {\n        require(amos[amo_address], \"Invalid AMO\");\n        _;\n    }\n    \n    function collatDollarBalance() external view returns (uint256) {\n        (, uint256 collat_val_e18) = dollarBalances();\n        return collat_val_e18;\n    }\n    function dollarBalances() public view returns (uint256 frax_val_e18, uint256 collat_val_e18) {\n        frax_val_e18 = fraxDollarBalanceStored;\n        collat_val_e18 = collatDollarBalanceStored;\n    }\n    function allAMOAddresses() external view returns (address[] memory) {\n        return amos_array;\n    }\n    function allAMOsLength() external view returns (uint256) {\n        return amos_array.length;\n    }\n    function fraxTrackedGlobal() external view returns (int256) {\n        return int256(fraxDollarBalanceStored) - frax_mint_sum - (collat_borrowed_sum * int256(10 ** missing_decimals));\n    }\n    function fraxTrackedAMO(address amo_address) external view returns (int256) {\n        (uint256 frax_val_e18, ) = IAMO(amo_address).dollarBalances();\n        int256 frax_val_e18_corrected = int256(frax_val_e18) + correction_offsets_amos[amo_address][0];\n        return frax_val_e18_corrected - frax_mint_balances[amo_address] - ((collat_borrowed_balances[amo_address]) * int256(10 ** missing_decimals));\n    }\n    \n    function syncDollarBalances() public {\n        uint256 total_frax_value_d18 = 0;\n        uint256 total_collateral_value_d18 = 0; \n        for (uint i = 0; i < amos_array.length; i++){ \n            address amo_address = amos_array[i];\n            if (amo_address != address(0)){\n                (uint256 frax_val_e18, uint256 collat_val_e18) = IAMO(amo_address).dollarBalances();\n                total_frax_value_d18 += uint256(int256(frax_val_e18) + correction_offsets_amos[amo_address][0]);\n                total_collateral_value_d18 += uint256(int256(collat_val_e18) + correction_offsets_amos[amo_address][1]);\n            }\n        }\n        fraxDollarBalanceStored = total_frax_value_d18;\n        collatDollarBalanceStored = total_collateral_value_d18;\n    }\n    \n    function oldPoolRedeem(uint256 frax_amount) external onlyByOwnGov {\n        uint256 redemption_fee = old_pool.redemption_fee();\n        uint256 col_price_usd = old_pool.getCollateralPrice();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        uint256 redeem_amount_E6 = ((frax_amount * (uint256(1e6) - redemption_fee)) / 1e6) / (10 ** missing_decimals);\n        uint256 expected_collat_amount = (redeem_amount_E6 * global_collateral_ratio) / 1e6;\n        expected_collat_amount = (expected_collat_amount * 1e6) / col_price_usd;\n        require((collat_borrowed_sum + int256(expected_collat_amount)) <= collat_borrow_cap, \"Borrow cap\");\n        collat_borrowed_sum += int256(expected_collat_amount);\n        FRAX.pool_mint(address(this), frax_amount);\n        FRAX.approve(address(old_pool), frax_amount);\n        old_pool.redeemFractionalFRAX(frax_amount, 0, 0);\n    }\n    function oldPoolCollectAndGive(address destination_amo) external onlyByOwnGov validAMO(destination_amo) {\n        uint256 collat_amount = old_pool.redeemCollateralBalances(address(this));\n        \n        old_pool.collectRedemption();\n        collat_borrowed_balances[destination_amo] += int256(collat_amount);\n        TransferHelper.safeTransfer(collateral_address, destination_amo, collat_amount);\n        syncDollarBalances();\n    }\n    \n    function mintFraxForAMO(address destination_amo, uint256 frax_amount) external onlyByOwnGov validAMO(destination_amo) {\n        int256 frax_amt_i256 = int256(frax_amount);\n        require((frax_mint_sum + frax_amt_i256) <= frax_mint_cap, \"Mint cap reached\");\n        frax_mint_balances[destination_amo] += frax_amt_i256;\n        frax_mint_sum += frax_amt_i256;\n        uint256 current_collateral_E18 = FRAX.globalCollateralValue();\n        uint256 cur_frax_supply = FRAX.totalSupply();\n        uint256 new_frax_supply = cur_frax_supply + frax_amount;\n        uint256 new_cr = (current_collateral_E18 * PRICE_PRECISION) / new_frax_supply;\n        require(new_cr >= min_cr, \"CR would be too low\");\n        FRAX.pool_mint(destination_amo, frax_amount);\n        syncDollarBalances();\n    }\n    function burnFraxFromAMO(uint256 frax_amount) external validAMO(msg.sender) {\n        int256 frax_amt_i256 = int256(frax_amount);\n        FRAX.pool_burn_from(msg.sender, frax_amount);\n        frax_mint_balances[msg.sender] -= frax_amt_i256;\n        frax_mint_sum -= frax_amt_i256;\n        syncDollarBalances();\n    }\n    function mintFxsForAMO(address destination_amo, uint256 fxs_amount) external onlyByOwnGov validAMO(destination_amo) {\n        int256 fxs_amt_i256 = int256(fxs_amount);\n        require((fxs_mint_sum + fxs_amt_i256) <= fxs_mint_cap, \"Mint cap reached\");\n        fxs_mint_balances[destination_amo] += fxs_amt_i256;\n        fxs_mint_sum += fxs_amt_i256;\n        FXS.pool_mint(destination_amo, fxs_amount);\n        syncDollarBalances();\n    }\n    function burnFxsFromAMO(uint256 fxs_amount) external validAMO(msg.sender) {\n        int256 fxs_amt_i256 = int256(fxs_amount);\n        FXS.pool_burn_from(msg.sender, fxs_amount);\n        fxs_mint_balances[msg.sender] -= fxs_amt_i256;\n        fxs_mint_sum -= fxs_amt_i256;\n        syncDollarBalances();\n    }\n    function giveCollatToAMO(\n        address destination_amo,\n        uint256 collat_amount\n    ) external onlyByOwnGov validAMO(destination_amo) {\n        int256 collat_amount_i256 = int256(collat_amount);\n        require((collat_borrowed_sum + collat_amount_i256) <= collat_borrow_cap, \"Borrow cap\");\n        collat_borrowed_balances[destination_amo] += collat_amount_i256;\n        collat_borrowed_sum += collat_amount_i256;\n        pool.amoMinterBorrow(collat_amount);\n        TransferHelper.safeTransfer(collateral_address, destination_amo, collat_amount);\n        syncDollarBalances();\n    }\n    function receiveCollatFromAMO(uint256 usdc_amount) external validAMO(msg.sender) {\n        int256 collat_amt_i256 = int256(usdc_amount);\n        TransferHelper.safeTransferFrom(collateral_address, msg.sender, address(pool), usdc_amount);\n        collat_borrowed_balances[msg.sender] -= collat_amt_i256;\n        collat_borrowed_sum -= collat_amt_i256;\n        syncDollarBalances();\n    }\n    \n    function addAMO(address amo_address, bool sync_too) public onlyByOwnGov {\n        require(amo_address != address(0), \"Zero address detected\");\n        (uint256 frax_val_e18, uint256 collat_val_e18) = IAMO(amo_address).dollarBalances();\n        require(frax_val_e18 >= 0 && collat_val_e18 >= 0, \"Invalid AMO\");\n        require(amos[amo_address] == false, \"Address already exists\");\n        amos[amo_address] = true; \n        amos_array.push(amo_address);\n        frax_mint_balances[amo_address] = 0;\n        fxs_mint_balances[amo_address] = 0;\n        collat_borrowed_balances[amo_address] = 0;\n        correction_offsets_amos[amo_address][0] = 0;\n        correction_offsets_amos[amo_address][1] = 0;\n        if (sync_too) syncDollarBalances();\n        emit AMOAdded(amo_address);\n    }\n    function removeAMO(address amo_address, bool sync_too) public onlyByOwnGov {\n        require(amo_address != address(0), \"Zero address detected\");\n        require(amos[amo_address] == true, \"Address nonexistant\");\n        \n        delete amos[amo_address];\n        for (uint i = 0; i < amos_array.length; i++){ \n            if (amos_array[i] == amo_address) {\n                amos_array[i] = address(0);\n                break;\n            }\n        }\n        if (sync_too) syncDollarBalances();\n        emit AMORemoved(amo_address);\n    }\n    function setTimelock(address new_timelock) external onlyByOwnGov {\n        require(new_timelock != address(0), \"Timelock address cannot be 0\");\n        timelock_address = new_timelock;\n    }\n    function setCustodian(address _custodian_address) external onlyByOwnGov {\n        require(_custodian_address != address(0), \"Custodian address cannot be 0\");        \n        custodian_address = _custodian_address;\n    }\n    function setFraxMintCap(uint256 _frax_mint_cap) external onlyByOwnGov {\n        frax_mint_cap = int256(_frax_mint_cap);\n    }\n    function setFxsMintCap(uint256 _fxs_mint_cap) external onlyByOwnGov {\n        fxs_mint_cap = int256(_fxs_mint_cap);\n    }\n    function setCollatBorrowCap(uint256 _collat_borrow_cap) external onlyByOwnGov {\n        collat_borrow_cap = int256(_collat_borrow_cap);\n    }\n    function setMinimumCollateralRatio(uint256 _min_cr) external onlyByOwnGov {\n        min_cr = _min_cr;\n    }\n    function setAMOCorrectionOffsets(address amo_address, int256 frax_e18_correction, int256 collat_e18_correction) external onlyByOwnGov {\n        correction_offsets_amos[amo_address][0] = frax_e18_correction;\n        correction_offsets_amos[amo_address][1] = collat_e18_correction;\n        syncDollarBalances();\n    }\n    function setFraxPool(address _pool_address) external onlyByOwnGov {\n        pool = FraxPoolV3(_pool_address);\n        require(pool.collateralAddrToIdx(collateral_address) == col_idx, \"col_idx mismatch\");\n    }\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\n        \n        emit Recovered(tokenAddress, tokenAmount);\n    }\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyByOwnGov returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\n        return (success, result);\n    }\n    \n    event AMOAdded(address amo_address);\n    event AMORemoved(address amo_address);\n    event Recovered(address token, uint256 amount);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    \n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\ninterface ICrossChainOracle {\n    function getPrice(address token_address) external view returns (uint256 token_price);\n}\ninterface ICrossChainAMO {\n    function allDollarBalances() external view returns (uint256 frax_val_e18, uint256 fxs_val_e18, uint256 collat_val_e18, uint256 total_val_e18);\n}\ncontract CrossChainBridgeBacker is Owned {\n    using SafeERC20 for ERC20;\n    \n    IAnyswapV4ERC20 public anyFRAX;\n    CrossChainCanonical public canFRAX;\n    IAnyswapV4ERC20 public anyFXS;\n    CrossChainCanonical public canFXS;\n    ERC20 public collateral_token;\n    ICrossChainOracle public cross_chain_oracle;\n    address public timelock_address;\n    address[] public amos_array;\n    mapping(address => bool) public eoa_amos;\n    mapping(address => bool) public amos;\n    \n    string public name;\n    uint256 private constant PRICE_PRECISION = 1e6;\n    address[3] public bridge_addresses;\n    address public destination_address_override;\n    string public non_evm_destination_address;\n    mapping(address => uint256) public frax_lent_balances;\n    uint256 public frax_lent_sum = 0;\n    uint256 public frax_bridged_back_sum = 0;\n    mapping(address => uint256) public fxs_lent_balances;\n    uint256 public fxs_lent_sum = 0;\n    uint256 public fxs_bridged_back_sum = 0;\n    mapping(address => uint256) public collat_lent_balances;\n    uint256 public collat_lent_sum = 0;\n    uint256 public collat_bridged_back_sum = 0;\n    uint256 public missing_decimals;\n    \n    modifier onlyByOwnGov() {\n        require(msg.sender == owner || msg.sender == timelock_address, \"Not owner or timelock\");\n        _;\n    }\n    modifier validAMO(address amo_address) {\n        require(amos[amo_address], \"Invalid AMO\");\n        _;\n    }\n    modifier validCanonicalToken(address token_address) {\n        require (\n                token_address == address(canFRAX) || \n                token_address == address(canFXS) ||\n                token_address == address(collateral_token), \"Invalid canonical token\"\n            );\n        _;\n    }\n    \n    constructor (\n        address _owner,\n        address _timelock_address,\n        address _cross_chain_oracle_address,\n        address[5] memory _token_addresses,\n        address[3] memory _bridge_addresses,\n        address _destination_address_override,\n        string memory _non_evm_destination_address,\n        string memory _name\n    ) Owned(_owner) {\n        timelock_address = _timelock_address;\n        cross_chain_oracle = ICrossChainOracle(_cross_chain_oracle_address);\n        anyFRAX = IAnyswapV4ERC20(_token_addresses[0]);\n        canFRAX = CrossChainCanonical(_token_addresses[1]);\n        anyFXS = IAnyswapV4ERC20(_token_addresses[2]);\n        canFXS = CrossChainCanonical(_token_addresses[3]);\n        collateral_token = ERC20(_token_addresses[4]);\n        missing_decimals = uint(18) - collateral_token.decimals();\n        bridge_addresses = _bridge_addresses;\n        destination_address_override = _destination_address_override;\n        non_evm_destination_address = _non_evm_destination_address;\n        name = _name;\n        amos[address(this)] = true; \n        amos_array.push(address(this));\n        frax_lent_balances[address(this)] = 0;\n        fxs_lent_balances[address(this)] = 0;\n        collat_lent_balances[address(this)] = 0;\n    }\n    \n    function allAMOAddresses() external view returns (address[] memory) {\n        return amos_array;\n    }\n    function allAMOsLength() external view returns (uint256) {\n        return amos_array.length;\n    }\n    function getTokenType(address token_address) public view returns (uint256) {\n        if (token_address == address(anyFRAX) || token_address == address(canFRAX)) return 0;\n        else if (token_address == address(anyFXS) || token_address == address(canFXS)) return 1;\n        else if (token_address == address(collateral_token)) return 2;\n        revert(\"getTokenType: Invalid token\");\n    }\n    function showTokenBalances() public view returns (uint256[5] memory tkn_bals) {\n        tkn_bals[0] = anyFRAX.balanceOf(address(this));\n        tkn_bals[1] = canFRAX.balanceOf(address(this));\n        tkn_bals[2] = anyFXS.balanceOf(address(this));\n        tkn_bals[3] = canFXS.balanceOf(address(this));\n        tkn_bals[4] = collateral_token.balanceOf(address(this));\n    }\n    function showAllocations() public view returns (uint256[12] memory allocations) {\n        uint256[5] memory tkn_bals = showTokenBalances();\n        allocations[0] = tkn_bals[0] + tkn_bals[1];\n        allocations[1] = frax_lent_sum;\n        allocations[2] = allocations[0] + allocations[1];\n        allocations[3] = tkn_bals[2] + tkn_bals[3];\n        allocations[4] = fxs_lent_sum;\n        allocations[5] = allocations[3] + allocations[4];\n        allocations[6] = (allocations[5] * (cross_chain_oracle.getPrice(address(canFXS)))) / PRICE_PRECISION;\n        allocations[7] = tkn_bals[4];\n        allocations[8] = collat_lent_sum;\n        allocations[9] = allocations[7] + allocations[8];\n        allocations[10] = allocations[9] * (10 ** missing_decimals);\n    \n        allocations[11] = allocations[2] + allocations[6] + allocations[10];\n    }\n    function allBalances() public view returns (\n        uint256 frax_ttl, \n        uint256 fxs_ttl,\n        uint256 col_ttl,\n        uint256 ttl_val_usd_e18\n    ) {\n        uint256[12] memory allocations = showAllocations();\n        frax_ttl = allocations[2];\n        fxs_ttl = allocations[5];\n        col_ttl = allocations[9];\n        ttl_val_usd_e18 = allocations[11];\n        for (uint i = 1; i < amos_array.length; i++){ \n            if (amos_array[i] != address(0) && !eoa_amos[amos_array[i]]){\n                (\n                    uint256 frax_bal, \n                    uint256 fxs_bal, \n                    uint256 collat_bal,\n                    uint256 total_val_e18\n                ) = ICrossChainAMO(amos_array[i]).allDollarBalances();\n                frax_ttl += frax_bal;\n                fxs_ttl += fxs_bal;\n                col_ttl += collat_bal;\n                ttl_val_usd_e18 += total_val_e18;\n            }\n        }\n    }\n    \n    function selfBridge(uint256 token_type, uint256 token_amount, bool do_swap) external onlyByOwnGov {\n        require(token_type == 0 || token_type == 1 || token_type == 2, 'Invalid token type');\n        _receiveBack(address(this), token_type, token_amount, true, do_swap);\n    }\n    function receiveBackViaAMO(address canonical_token_address, uint256 token_amount, bool do_bridging) external validCanonicalToken(canonical_token_address) validAMO(msg.sender) {\n        TransferHelper.safeTransferFrom(canonical_token_address, msg.sender, address(this), token_amount);\n        uint256 token_type = getTokenType(canonical_token_address); \n        _receiveBack(msg.sender, token_type, token_amount, do_bridging, true);\n    }\n    function _receiveBack(address from_address, uint256 token_type, uint256 token_amount, bool do_bridging, bool do_swap) internal {\n        if (do_bridging) {\n            if (token_type == 0) {\n                if (do_swap) _swapCanonicalForAny(0, token_amount);\n            }\n            else if (token_type == 1){\n                if (do_swap) _swapCanonicalForAny(1, token_amount);\n            }\n            address address_to_send_to = address(this);\n            if (destination_address_override != address(0)) address_to_send_to = destination_address_override;\n            _bridgingLogic(token_type, address_to_send_to, token_amount);\n        }\n        if (token_type == 0){\n            if (token_amount >= frax_lent_balances[from_address]) frax_lent_balances[from_address] = 0;\n            else frax_lent_balances[from_address] -= token_amount;\n            if (token_amount >= frax_lent_sum) frax_lent_sum = 0;\n            else frax_lent_sum -= token_amount;\n            if (do_bridging) frax_bridged_back_sum += token_amount;\n        }\n        else if (token_type == 1){\n            if (token_amount >= fxs_lent_balances[from_address]) fxs_lent_balances[from_address] = 0;\n            else fxs_lent_balances[from_address] -= token_amount;\n            if (token_amount >= fxs_lent_sum) fxs_lent_sum = 0;\n            else fxs_lent_sum -= token_amount;\n            if (do_bridging) fxs_bridged_back_sum += token_amount;\n        }\n        else {\n            if (token_amount >= collat_lent_balances[from_address]) collat_lent_balances[from_address] = 0;\n            else collat_lent_balances[from_address] -= token_amount;\n            if (token_amount >= collat_lent_sum) collat_lent_sum = 0;\n            else collat_lent_sum -= token_amount;\n            if (do_bridging) collat_bridged_back_sum += token_amount;\n        }\n    }\n    function _bridgingLogic(uint256 token_type, address address_to_send_to, uint256 token_amount) internal virtual {\n        revert(\"Need bridging logic\");\n    }\n    \n    function lendFraxToAMO(address destination_amo, uint256 frax_amount) external onlyByOwnGov validAMO(destination_amo) {\n        frax_lent_balances[destination_amo] += frax_amount;\n        frax_lent_sum += frax_amount;\n        TransferHelper.safeTransfer(address(canFRAX), destination_amo, frax_amount);\n    }\n    function lendFxsToAMO(address destination_amo, uint256 fxs_amount) external onlyByOwnGov validAMO(destination_amo) {\n        fxs_lent_balances[destination_amo] += fxs_amount;\n        fxs_lent_sum += fxs_amount;\n        TransferHelper.safeTransfer(address(canFXS), destination_amo, fxs_amount);\n    }\n    function lendCollatToAMO(address destination_amo, uint256 collat_amount) external onlyByOwnGov validAMO(destination_amo) {\n        collat_lent_balances[destination_amo] += collat_amount;\n        collat_lent_sum += collat_amount;\n        TransferHelper.safeTransfer(address(collateral_token), destination_amo, collat_amount);\n    }\n    \n    \n    function swapAnyForCanonical(uint256 token_type, uint256 token_amount) external onlyByOwnGov {\n        _swapAnyForCanonical(token_type, token_amount);\n    }\n    function _swapAnyForCanonical(uint256 token_type, uint256 token_amount) internal {\n        if (token_type == 0) {\n            anyFRAX.approve(address(canFRAX), token_amount);\n            canFRAX.exchangeOldForCanonical(address(anyFRAX), token_amount);\n        }\n        else {\n            anyFXS.approve(address(canFXS), token_amount);\n            canFXS.exchangeOldForCanonical(address(anyFXS), token_amount);\n        }\n    }\n    function swapCanonicalForAny(uint256 token_type, uint256 token_amount) external onlyByOwnGov {\n        _swapCanonicalForAny(token_type, token_amount);\n    }\n    function _swapCanonicalForAny(uint256 token_type, uint256 token_amount) internal {\n        if (token_type == 0) {\n            canFRAX.approve(address(canFRAX), token_amount);\n            canFRAX.exchangeCanonicalForOld(address(anyFRAX), token_amount);\n        }\n        else {\n            canFXS.approve(address(canFXS), token_amount);\n            canFXS.exchangeCanonicalForOld(address(anyFXS), token_amount);\n        }\n    }\n    function giveAnyToCan(uint256 token_type, uint256 token_amount) external onlyByOwnGov {\n        if (token_type == 0) {\n            TransferHelper.safeTransfer(address(anyFRAX), address(canFRAX), token_amount);\n        }\n        else {\n            TransferHelper.safeTransfer(address(anyFXS), address(canFXS), token_amount);\n        }\n    }\n    function mintCanonicalFrax(uint256 frax_amount) external onlyByOwnGov {\n        canFRAX.minter_mint(address(this), frax_amount);\n    }\n    function burnCanonicalFrax(uint256 frax_amount) external onlyByOwnGov {\n        canFRAX.minter_burn(frax_amount);\n    }\n    function mintCanonicalFxs(uint256 fxs_amount) external onlyByOwnGov {\n        canFXS.minter_mint(address(this), fxs_amount);\n    }\n    function burnCanonicalFxs(uint256 fxs_amount) external onlyByOwnGov {\n        canFXS.minter_burn(fxs_amount);\n    }\n    \n    function collectBridgeTokens(uint256 token_type, address bridge_token_address, uint256 token_amount) external onlyByOwnGov {\n        if (token_type == 0) {\n            canFRAX.withdrawBridgeTokens(bridge_token_address, token_amount);\n        }\n        else if (token_type == 1) {\n            canFXS.withdrawBridgeTokens(bridge_token_address, token_amount);\n        }\n        else {\n            revert(\"Invalid token_type\");\n        }\n    }\n    \n    function addAMO(address amo_address, bool is_eoa) external onlyByOwnGov {\n        require(amo_address != address(0), \"Zero address detected\");\n        if (is_eoa) {\n            eoa_amos[amo_address] = true;\n        }\n        else {\n            (uint256 frax_val_e18, uint256 fxs_val_e18, uint256 collat_val_e18, uint256 total_val_e18) = ICrossChainAMO(amo_address).allDollarBalances();\n            require(frax_val_e18 >= 0 && fxs_val_e18 >= 0 && collat_val_e18 >= 0 && total_val_e18 >= 0, \"Invalid AMO\");\n        }\n        require(amos[amo_address] == false, \"Address already exists\");\n        amos[amo_address] = true; \n        amos_array.push(amo_address);\n        frax_lent_balances[amo_address] = 0;\n        fxs_lent_balances[amo_address] = 0;\n        collat_lent_balances[amo_address] = 0;\n        emit AMOAdded(amo_address);\n    }\n    function removeAMO(address amo_address) external onlyByOwnGov {\n        require(amo_address != address(0), \"Zero address detected\");\n        require(amos[amo_address] == true, \"Address nonexistant\");\n        \n        delete amos[amo_address];\n        for (uint i = 0; i < amos_array.length; i++){ \n            if (amos_array[i] == amo_address) {\n                amos_array[i] = address(0);\n                break;\n            }\n        }\n        emit AMORemoved(amo_address);\n    }\n    \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\n        emit RecoveredERC20(tokenAddress, tokenAmount);\n    }\n    function setOracleAddress(address _new_cc_oracle_address) external onlyByOwnGov {\n        cross_chain_oracle = ICrossChainOracle(_new_cc_oracle_address);\n    }\n    function setTimelock(address _new_timelock) external onlyByOwnGov {\n        timelock_address = _new_timelock;\n    }\n    function setBridgeInfo(\n        address _frax_bridge_address, \n        address _fxs_bridge_address, \n        address _collateral_bridge_address, \n        address _destination_address_override, \n        string memory _non_evm_destination_address\n    ) external onlyByOwnGov {\n        require(\n            _frax_bridge_address != address(0) && \n            _fxs_bridge_address != address(0) &&\n            _collateral_bridge_address != address(0)\n        , \"Invalid bridge address\");\n        bridge_addresses = [_frax_bridge_address, _fxs_bridge_address, _collateral_bridge_address];\n        \n        destination_address_override = _destination_address_override;\n        non_evm_destination_address = _non_evm_destination_address;\n        \n        emit BridgeInfoChanged(_frax_bridge_address, _fxs_bridge_address, _collateral_bridge_address, _destination_address_override, _non_evm_destination_address);\n    }\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external onlyByOwnGov returns (bool, bytes memory) {\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\n        return (success, result);\n    }\n    \n    event AMOAdded(address amo_address);\n    event AMORemoved(address amo_address);\n    event RecoveredERC20(address token, uint256 amount);\n    event BridgeInfoChanged(address frax_bridge_address, address fxs_bridge_address, address collateral_bridge_address, address destination_address_override, string non_evm_destination_address);\n}\ninterface IBridgeRouter {\n  function PRE_FILL_FEE_DENOMINATOR() external view returns (uint256);\n  function PRE_FILL_FEE_NUMERATOR() external view returns (uint256);\n  function VERSION() external view returns (uint8);\n  function enrollCustom(uint32 _domain, bytes32 _id, address _custom) external;\n  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external;\n  function handle(uint32 _origin, uint32 _nonce, bytes32 _sender, bytes memory _message) external;\n  function initialize(address _tokenRegistry, address _xAppConnectionManager) external;\n  function liquidityProvider(bytes32) external view returns (address);\n  function migrate(address _oldRepr) external;\n  function owner() external view returns (address);\n  function preFill(uint32 _origin, uint32 _nonce, bytes memory _message) external;\n  function remotes(uint32) external view returns (bytes32);\n  function renounceOwnership() external;\n  function send(address _token, uint256 _amount, uint32 _destination, bytes32 _recipient, bool _enableFast) external;\n  function setXAppConnectionManager(address _xAppConnectionManager) external;\n  function tokenRegistry() external view returns (address);\n  function transferOwnership(address newOwner) external;\n  function xAppConnectionManager() external view returns (address);\n}\ncontract CrossChainBridgeBacker_EVMOS_Nomad is CrossChainBridgeBacker {\n    uint32 public destination = 6648936;\n    bytes32 public recipient;\n    constructor (\n        address _owner,\n        address _timelock_address,\n        address _cross_chain_oracle_address,\n        address[5] memory _token_addresses,\n        address[3] memory _bridge_addresses,\n        address _destination_address_override,\n        string memory _non_evm_destination_address,\n        string memory _name\n    ) \n    CrossChainBridgeBacker(_owner, _timelock_address, _cross_chain_oracle_address, _token_addresses, _bridge_addresses, _destination_address_override, _non_evm_destination_address, _name)\n    {}\n    function setDestination(uint32 _destination) external onlyByOwnGov {\n        destination = _destination;\n    }\n    function setRecipient(bytes32 _recipient) external onlyByOwnGov {\n        recipient = _recipient;\n    }\n    function _bridgingLogic(uint256 token_type, address address_to_send_to, uint256 token_amount) internal override {\n        if (token_type == 0){\n            anyFRAX.approve(bridge_addresses[token_type], token_amount);\n            IBridgeRouter(bridge_addresses[token_type]).send(address(anyFRAX), token_amount, destination, recipient, false);\n        }\n        else if (token_type == 1) {\n            anyFRAX.approve(bridge_addresses[token_type], token_amount);\n            IBridgeRouter(bridge_addresses[token_type]).send(address(anyFXS), token_amount, destination, recipient, false);\n        }\n        else {\n            anyFRAX.approve(bridge_addresses[token_type], token_amount);\n            IBridgeRouter(bridge_addresses[token_type]).send(address(collateral_token), token_amount, destination, recipient, false);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}